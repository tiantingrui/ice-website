(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{444:function(e,t,n){"use strict";n.r(t);var r=n(22),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"vue3-proxy-实现响应式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue3-proxy-实现响应式"}},[e._v("#")]),e._v(" Vue3 - Proxy 实现响应式")]),e._v(" "),n("ul",[n("li",[e._v("对比Object.defineProperty")]),e._v(" "),n("li",[e._v("Proxy实现响应式")]),e._v(" "),n("li",[e._v("两者对比")])]),e._v(" "),n("h2",{attrs:{id:"object-defineproperty"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#object-defineproperty"}},[e._v("#")]),e._v(" Object.defineProperty")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 触发更新视图\nfunction updateView() {\n    console.log('视图更新')\n}\n\n// 重新定义数组原型\nconst oldArrayProperty = Array.prototype\n// 创建新对象，原型指向 oldArrayProperty，再拓展新的方法不会影响原型，这样做避免污染全局原型\nconst arrProto = Object.create(oldArrayProperty);\n['push', 'pop', 'shift', 'unshift'].forEach(methodName => {\n    arrProto[methodName] = function() {\n        updateView() // 触发视图更新\n        oldArrayProperty[methodName].call(this, ...arguments)\n        // Array.prototype[methodName].call(this, ...arguments)\n    }\n})\n// 重新定义属性，监听起来\nfunction defineReactive(target, key, value) {\n    // 深度监听，就是说如果value 是 个对象\n    observer(value)\n\n    // 核心API\n    Object.defineProperty(target, key, {\n        get() {\n            return value\n        },\n        set(newVal) {\n            if (newVal !== value) {\n                // 深度监听， 万一set 的值是一个 object，下次更新之后就会监听到\n                observe(newVal)\n\n                // 设置新值\n                // 注意， value 一直在闭包中，此处设置完之后，在get 时也是会获取最新的值\n                value = newVal\n\n                // 触发更新视图\n                updateView()\n            }\n        }\n    })\n}\n\n// 监听对象属性\nfunction observer(target) {\n    if (typeof target !== 'object' || target === null) {\n        // 不是对象或者数组\n        return target\n    }\n\n    if (Array.isArray(target)) {\n        target.__proto__ = arrProto\n    }\n\n    // 重新定义各个属性（for in 也可以遍历数组）\n    for (let key in target) {\n        defineReactive(target, key, target[key])\n    }\n}\n\n// 准备数据\nconst data = {\n    name: 'terry',\n    age: 25,\n    info: {\n        base: '杭州'\n    },\n    list: [10, 20, 30]\n}\n\n// 监听数据\nobserver(data)\n\n// 测试\ndata.name = 'zmn'\ndata.age = 24\ndata.x = '100' // 新增属性，监听不到 -- 所以有 Vue.set\ndelete data.name // 删除属性，监听不到 -- 所以有 Vue.delete\ndata.info.base = '北京' // 深度监听\ndata.list.push(40) // 监听数组\n")])])]),n("h3",{attrs:{id:"object-defineproperty-的缺点"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#object-defineproperty-的缺点"}},[e._v("#")]),e._v(" Object.defineProperty 的缺点")]),e._v(" "),n("ul",[n("li",[e._v("深度监听，需要递归到底，一次性计算量大")]),e._v(" "),n("li",[e._v("无法监听新增属性/删除属性（Vue.set Vue.delete）")]),e._v(" "),n("li",[e._v("无法原生监听数组，需要特殊处理")])]),e._v(" "),n("h2",{attrs:{id:"proxy-实现响应式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#proxy-实现响应式"}},[e._v("#")]),e._v(" Proxy 实现响应式")]),e._v(" "),n("ul",[n("li",[e._v("基本使用")]),e._v(" "),n("li",[e._v("Reflect")])]),e._v(" "),n("h3",{attrs:{id:"proxy-基本使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#proxy-基本使用"}},[e._v("#")]),e._v(" Proxy 基本使用")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const data = {\n    name: 'terry',\n    age: 25\n}\n\n// const data = ['a', 'b', 'c']\n\nconst proxyData = new Proxy(data, {\n    get(target, key, receiver) {\n        // 只处理本身（非原型）的属性\n        const ownKeys = Reflect.ownKeys(target)\n        if (ownKeys.includes(key)) {\n            console.log('get', key)\n        }\n        const result = Reflect.get(target, key, receiver)\n        console.log('get', key)\n        return result // 返回结果\n    },\n    set(target, key, val, receiver) {\n        // 重复的数据不处理\n        const oldVal = target[key]\n        if (val === oldVal) {\n            return true\n        }\n        const result = Reflect.set(target, key, val, receiver)\n        console.log('set', key, val)\n        console.log('result', result)\n        return result // 是否式设置成功\n    },\n    deleteProperty(target, key) {\n        const result = Reflect.deleteProperty(target, key)\n        console.log('delete property', key)\n        console.log('result', result)\n        return result // 是否删除成功\n    }\n})\n")])])]),n("h3",{attrs:{id:"reflect-作用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#reflect-作用"}},[e._v("#")]),e._v(" Reflect 作用")]),e._v(" "),n("ul",[n("li",[e._v("和Proxy能力一一对应")]),e._v(" "),n("li",[e._v("规范化、标准化、函数式")]),e._v(" "),n("li",[e._v("替代掉 Object 上的工具函数，让Object 更纯净")])]),e._v(" "),n("h3",{attrs:{id:"proxy-实现响应式-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#proxy-实现响应式-2"}},[e._v("#")]),e._v(" Proxy 实现响应式")]),e._v(" "),n("ul",[n("li",[e._v("深度监听，性能更好")]),e._v(" "),n("li",[e._v("可监听 新增/删除 属性")]),e._v(" "),n("li",[e._v("可监听数组变化（原生支持数组变化）")])]),e._v(" "),n("h2",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),n("ul",[n("li",[e._v("Proxy 能 规避掉Object.defineProperty 的问题")]),e._v(" "),n("li",[e._v("Proxy 无法兼容所有浏览器，无法polyfill")])])])}),[],!1,null,null,null);t.default=a.exports}}]);